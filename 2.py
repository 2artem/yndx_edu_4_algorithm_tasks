def partition(array, left, right):
    '''
    Функция возвращающая индекс, выбранного в ней,  опорного элемента,
    а так же разделяющая элементы переданного массива на:
    с левой стороны от опорного - элементы меньшие опорного;
    с правой стороны от опорного - элементы большие опорного.
    '''
    # Возьмем крайний правый элемент из массива в качестве опорного элемента
    pivot = array[right]
    # Инициируем указатель, стоящий перед большим элементом
    cursor = left - 1
    # Пробежимся вправо по всем элементам вошедшего массива,
    # кроме самого pivot(последнего в массиве),
    # сравнивая их с опорным элементом
    for elem in range(left, right):
        # Если элемент меньше или равен опорному элементу,
        # то мы его переносим в начало массива, в положение курсора cursor
        if array[elem] <= pivot:
            # двигаем курсор, он указывает на индекс перед большим элементом
            cursor = cursor + 1
            # Поменяем его местами с большим элементом,
            # на который указывает cursor
            array[cursor], array[elem] = array[elem], array[cursor]
    # Теперь поменяем местами опорный элемент,
    # с элементом, который больше опорного элемента
    # и в который впервые уперся указатель cursor
    array[cursor + 1], array[right] = array[right], array[cursor + 1]
    return cursor + 1


def in_place_quick_sort(array, left=None, right=None):
    '''Функция выполняющая эффективную быструю сортировку.'''
    # Инициализируем крайние элементы массива
    # при первом вызове функции без аргументов
    if left is None and right is None:
        left = 0
        right = len(array)-1
    # Массивы с 0 или 1 элементами фактически отсортированы и
    # элементы массива переставляться не будут, иначе выполняется условие:
    if left < right:
        pivot_index = partition(array, left, right)
        # Рекурсивная сортировка общего массива, в его части с меньшеми числами
        # чем опорный элемент (без учета этого элемента)
        in_place_quick_sort(array, left, pivot_index - 1)
        # Рекурсивная сортировка общего массива, в его части с большими числами
        # чем опорный элемент (без учета этого элемента)
        in_place_quick_sort(array, pivot_index + 1, right)

if __name__ == '__main__':
    array = []
    # Количество участников
    n = int(input())
    # парсинг записей об участниках
    for inpt in range(n):
        text = str(input()).split(" ")
        array.append([int('-' + text[1]), int(text[2]), text[0]])
    in_place_quick_sort(array)
    for i in array:
        print(i[2])
